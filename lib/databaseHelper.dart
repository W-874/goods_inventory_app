import 'dart:async';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'dataClass.dart';


// --- Table and Column Constants (as defined before) ---
// --- Table Names ---
const String tableGoods = 'goods';
const String tableRawMaterials = 'rawmaterials';
const String tableBillOfMaterials = 'billofmaterials';
const String tablePendingGoods = 'pending_goods';

// --- Goods Table Columns ---
const String columnGoodsId = 'goods_id';
const String columnName = 'name';
const String columnGoodsRemainingQuantity = 'remaining_quantity';
const String columnPrice = 'price';
const String columnDescription = 'description';

// --- RawMaterials Table Columns ---
const String columnRawMaterialId = 'raw_material_id';
// columnName is already defined
const String columnRawMaterialRemainingQuantity = 'remaining_quantity';
// columnPrice is already defined
// columnDescription is already defined

// --- BillOfMaterials Table Columns ---
// columnGoodsId is already defined (from Goods)
// columnRawMaterialId is already defined (from RawMaterials)
const String columnQuantityNeeded = 'quantity_needed';

// --- PendingGoods Table Columns ---
const String columnPendingId = 'pending_id';
const String columnQuantityInProduction = 'quantity_in_production';
const String columnStartDate = 'start_date';
const String columnStatus = 'status';

class DatabaseHelper {
  static const _databaseName = "MyInventory.db";
  static const _databaseVersion = 2; // Increment this for schema changes

  DatabaseHelper._privateConstructor();
  static final DatabaseHelper instance = DatabaseHelper._privateConstructor();

  static Database? _database;
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB();
    return _database!;
  }

  Future<Database> _initDB() async {
    String path = join(await getDatabasesPath(), _databaseName);
    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
      onConfigure: _onConfigure, // Enable foreign keys
      onUpgrade: _onUpgrade, // Add this for schema migrations
    );
  }

  Future _onConfigure(Database db) async {
    // Enable foreign key support for ON DELETE CASCADE etc.
    await db.execute('PRAGMA foreign_keys = ON');
  }

  Future _onCreate(Database db, int version) async {
    await _onUpgrade(db, 0, version);
  }

  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    var batch = db.batch();
    if (oldVersion < 1) {
      // Version 1 Tables...
      batch.execute('''
      CREATE TABLE $tableGoods (
        $columnGoodsId INTEGER PRIMARY KEY AUTOINCREMENT, 
        $columnName TEXT NOT NULL,
        $columnGoodsRemainingQuantity INTEGER NOT NULL,
        $columnPrice REAL NOT NULL, 
        $columnDescription TEXT
      )
    ''');
    // Add AUTOINCREMENT if your IDs are auto-generated by SQLite:
    // $columnGoodsId INTEGER PRIMARY KEY AUTOINCREMENT,

    batch.execute('''
      CREATE TABLE $tableRawMaterials (
        $columnRawMaterialId INTEGER PRIMARY KEY AUTOINCREMENT,
        $columnName TEXT NOT NULL,
        $columnRawMaterialRemainingQuantity INTEGER NOT NULL,
        $columnPrice REAL NOT NULL, 
        $columnDescription TEXT
      )
    ''');
    // $columnRawMaterialId INTEGER PRIMARY KEY AUTOINCREMENT,


    batch.execute('''
      CREATE TABLE $tableBillOfMaterials (
        $columnGoodsId INTEGER NOT NULL,
        $columnRawMaterialId INTEGER NOT NULL,
        $columnQuantityNeeded INTEGER NOT NULL,
        PRIMARY KEY ($columnGoodsId, $columnRawMaterialId),
        FOREIGN KEY ($columnGoodsId) REFERENCES $tableGoods ($columnGoodsId) ON DELETE CASCADE,
        FOREIGN KEY ($columnRawMaterialId) REFERENCES $tableRawMaterials ($columnRawMaterialId) ON DELETE CASCADE
      )
    ''');
    await batch.commit();
    }
    if (oldVersion < 2) {
      // Updated Version 2 Table with the status column
       batch.execute('''
        CREATE TABLE $tablePendingGoods (
          $columnPendingId INTEGER PRIMARY KEY AUTOINCREMENT,
          $columnGoodsId INTEGER NOT NULL,
          $columnQuantityInProduction INTEGER NOT NULL,
          $columnStartDate TEXT NOT NULL,
          $columnStatus INTEGER NOT NULL DEFAULT 1,
          FOREIGN KEY ($columnGoodsId) REFERENCES $tableGoods ($columnGoodsId) ON DELETE CASCADE
        )
      ''');
    }
    await batch.commit();
  }

  // --- Goods Table Operations ---
  Future<int> createGood(Goods good) async {
    Database db = await instance.database;
    // If goodsId is autoincrementing, ensure good.toMap() omits it if ID is 0/null
    // The ID returned by insert is the new row ID.
    return await db.insert(tableGoods, good.toMap(forInsertAndAutoincrement: true));
  }

  Future<Goods?> getGood(int id) async {
    Database db = await instance.database;
    List<Map<String, dynamic>> maps = await db.query(
      tableGoods,
      columns: [columnGoodsId, columnName, columnGoodsRemainingQuantity, columnPrice, columnDescription], // Be explicit
      where: '$columnGoodsId = ?',
      whereArgs: [id],
    );
    if (maps.isNotEmpty) {
      return Goods.fromMap(maps.first);
    }
    return null;
  }

  Future<List<Goods>> getAllGoods() async {
    Database db = await instance.database;
    final List<Map<String, dynamic>> maps = await db.query(tableGoods);
    return List.generate(maps.length, (i) {
      return Goods.fromMap(maps[i]);
    });
  }

  Future<int> updateGood(Goods good) async {
    Database db = await instance.database;
    return await db.update(
      tableGoods,
      good.toMap(), // forInsertAndAutoincrement should be false or omitted for updates
      where: '$columnGoodsId = ?',
      whereArgs: [good.goodsID],
    );
  }

  Future<int> deleteGood(int id) async {
    Database db = await instance.database;
    return await db.delete(
      tableGoods,
      where: '$columnGoodsId = ?',
      whereArgs: [id],
    );
  }

  // --- RawMaterials Table Operations ---
  Future<int> createRawMaterial(RawMaterials rawMaterial) async {
    Database db = await instance.database;
    return await db.insert(tableRawMaterials, rawMaterial.toMap(forInsertAndAutoincrement: true));
  }

  Future<RawMaterials?> getRawMaterial(int id) async {
    Database db = await instance.database;
    List<Map<String, dynamic>> maps = await db.query(
      tableRawMaterials,
      where: '$columnRawMaterialId = ?',
      whereArgs: [id],
    );
    if (maps.isNotEmpty) {
      return RawMaterials.fromMap(maps.first);
    }
    return null;
  }

  Future<List<RawMaterials>> getAllRawMaterials() async {
    Database db = await instance.database;
    final List<Map<String, dynamic>> maps = await db.query(tableRawMaterials);
    return List.generate(maps.length, (i) {
      return RawMaterials.fromMap(maps[i]);
    });
  }

  Future<int> updateRawMaterial(RawMaterials rawMaterial) async {
    Database db = await instance.database;
    return await db.update(
      tableRawMaterials,
      rawMaterial.toMap(),
      where: '$columnRawMaterialId = ?',
      whereArgs: [rawMaterial.materialID],
    );
  }

  Future<int> deleteRawMaterial(int id) async {
    Database db = await instance.database;
    return await db.delete(
      tableRawMaterials,
      where: '$columnRawMaterialId = ?',
      whereArgs: [id],
    );
  }

  // --- BillOfMaterials Table Operations ---
  Future<int> createBillOfMaterialEntry(BillOfMaterialEntry entry) async {
    Database db = await instance.database;
    return await db.insert(tableBillOfMaterials, entry.toMap(), conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<List<BillOfMaterialEntry>> getBillOfMaterialEntriesForGood(int goodsId) async {
    Database db = await instance.database;
    final List<Map<String, dynamic>> maps = await db.query(
      tableBillOfMaterials,
      where: '$columnGoodsId = ?',
      whereArgs: [goodsId],
    );
    return List.generate(maps.length, (i) {
      return BillOfMaterialEntry.fromMap(maps[i]);
    });
  }
  
  Future<List<BillOfMaterialEntry>> getBillOfMaterialEntriesForRawMaterial(int rawMaterialId) async {
    Database db = await instance.database;
    final List<Map<String, dynamic>> maps = await db.query(
      tableBillOfMaterials,
      where: '$columnRawMaterialId = ?',
      whereArgs: [rawMaterialId],
    );
    return List.generate(maps.length, (i) {
      return BillOfMaterialEntry.fromMap(maps[i]);
    });
  }

  Future<List<BillOfMaterialEntry>> getAllBillOfMaterialEntries() async {
    Database db = await instance.database;
    final List<Map<String, dynamic>> maps = await db.query(tableBillOfMaterials);
    return List.generate(maps.length, (i) {
      return BillOfMaterialEntry.fromMap(maps[i]);
    });
  }

  Future<int> updateBillOfMaterialEntryQuantity(BillOfMaterialEntry entry) async {
    Database db = await instance.database;
    return await db.update(
      tableBillOfMaterials,
      {columnQuantityNeeded: entry.quantityNeeded},
      where: '$columnGoodsId = ? AND $columnRawMaterialId = ?',
      whereArgs: [entry.goodsId, entry.rawMaterialId],
    );
  }

  Future<int> deleteBillOfMaterialEntry(int goodsId, int rawMaterialId) async {
    Database db = await instance.database;
    return await db.delete(
      tableBillOfMaterials,
      where: '$columnGoodsId = ? AND $columnRawMaterialId = ?',
      whereArgs: [goodsId, rawMaterialId],
    );
  }

  Future<int> deleteAllBOMEntriesForGood(int goodsId) async {
      Database db = await instance.database;
      return await db.delete(
          tableBillOfMaterials,
          where: '$columnGoodsId = ?',
          whereArgs: [goodsId],
      );
  }

    Future<List<BillOfMaterialEntry>> getBillOfMaterialsWithNames(int goodsId) async {
    Database db = await instance.database;
    final String query = '''
      SELECT
        bom.$columnGoodsId,
        bom.$columnRawMaterialId,
        bom.$columnQuantityNeeded,
        rm.$columnName
      FROM
        $tableBillOfMaterials bom
      JOIN
        $tableRawMaterials rm ON bom.$columnRawMaterialId = rm.$columnRawMaterialId
      WHERE
        bom.$columnGoodsId = ?
    ''';
    final List<Map<String, dynamic>> maps = await db.rawQuery(query, [goodsId]);
    return List.generate(maps.length, (i) {
      return BillOfMaterialEntry.fromMap(maps[i]);
    });
  }

  // --- PendingGoods Table Operations ---

  Future<List<PendingGood>> getAllPendingGoods() async {
    Database db = await instance.database;
    final String query = '''
      SELECT
        pg.$columnPendingId, pg.$columnGoodsId, pg.$columnQuantityInProduction, 
        pg.$columnStartDate, pg.$columnStatus, g.$columnName
      FROM
        $tablePendingGoods pg
      JOIN
        $tableGoods g ON pg.$columnGoodsId = g.$columnGoodsId
      WHERE
        pg.$columnStatus = 1
    ''';
    final List<Map<String, dynamic>> maps = await db.rawQuery(query);
    return List.generate(maps.length, (i) => PendingGood.fromMap(maps[i]));
  }

  Future<void> startProduction(int goodsId, int quantityToProduce) async {
    final db = await instance.database;
    await db.transaction((txn) async {
      // 1. Get the list of required materials (Bill of Materials)
      final bomMaps = await txn.query(tableBillOfMaterials, where: '$columnGoodsId = ?', whereArgs: [goodsId]);
      if (bomMaps.isEmpty) {
        throw Exception("This good has no Bill of Materials defined.");
      }
      final bomEntries = bomMaps.map((map) => BillOfMaterialEntry.fromMap(map)).toList();

      // 2. Check stock and deduct for each material
      for (final entry in bomEntries) {
        final requiredQty = entry.quantityNeeded * quantityToProduce;
        final materialMaps = await txn.query(tableRawMaterials, where: '$columnRawMaterialId = ?', whereArgs: [entry.rawMaterialId]);
        final material = RawMaterials.fromMap(materialMaps.first);

        if (material.quality < requiredQty) {
          throw Exception("Not enough ${material.name}. Required: $requiredQty, Available: ${material.quality}");
        }
        await txn.update(tableRawMaterials, {columnRawMaterialRemainingQuantity: material.quality - requiredQty}, where: '$columnRawMaterialId = ?', whereArgs: [entry.rawMaterialId]);
      }

      // 3. Create the pending good entry
      final pendingGood = PendingGood(
        goodsId: goodsId,
        quantityInProduction: quantityToProduce,
        startDate: DateTime.now(),
        isUnderConstruction: true, // Explicitly set status
      );
      await txn.insert(tablePendingGoods, pendingGood.toMap());
    });
  }

  Future<void> completeProduction(PendingGood pendingGood) async {
    final db = await instance.database;
    await db.transaction((txn) async {
      // 1. Get the current Good's stock
      final goodMaps = await txn.query(tableGoods, where: '$columnGoodsId = ?', whereArgs: [pendingGood.goodsId]);
      if (goodMaps.isEmpty) throw Exception("Good not found.");
      final good = Goods.fromMap(goodMaps.first);

      // 2. Update the Good's stock
      await txn.update(tableGoods, {columnGoodsRemainingQuantity: good.quality + pendingGood.quantityInProduction}, where: '$columnGoodsId = ?', whereArgs: [pendingGood.goodsId]);
      
      // 3. Update the status of the pending good entry to 0 (done)
      await txn.update(
          tablePendingGoods,
          {columnStatus: 0},
          where: '$columnPendingId = ?',
          whereArgs: [pendingGood.pendingId],
      );
    });
  }
  
  Future<void> cancelProduction(PendingGood pendingGood) async {
    final db = await instance.database;
    await db.transaction((txn) async {
      // 1. Get the list of materials that were used
      final bomMaps = await txn.query(tableBillOfMaterials, where: '$columnGoodsId = ?', whereArgs: [pendingGood.goodsId]);
      final bomEntries = bomMaps.map((map) => BillOfMaterialEntry.fromMap(map)).toList();

      // 2. Add the consumed quantity back to each raw material's stock
      for (final entry in bomEntries) {
        final consumedQty = entry.quantityNeeded * pendingGood.quantityInProduction;
        final materialMaps = await txn.query(tableRawMaterials, where: '$columnRawMaterialId = ?', whereArgs: [entry.rawMaterialId]);
        final material = RawMaterials.fromMap(materialMaps.first);
        await txn.update(tableRawMaterials, {columnRawMaterialRemainingQuantity: material.quality + consumedQty}, where: '$columnRawMaterialId = ?', whereArgs: [entry.rawMaterialId]);
      }

      // 3. Update the status of the pending good entry to 0 (canceled)
      await txn.update(
        tablePendingGoods,
        {columnStatus: 0},
        where: '$columnPendingId = ?',
        whereArgs: [pendingGood.pendingId],
      );
    });
  }

    Future<List<Goods>> getGoodsUsingRawMaterial(int rawMaterialId) async {
    final db = await instance.database;
    final String query = '''
      SELECT g.* FROM $tableGoods g
      JOIN $tableBillOfMaterials bom ON g.$columnGoodsId = bom.$columnGoodsId
      WHERE bom.$columnRawMaterialId = ?
    ''';
    final List<Map<String, dynamic>> maps = await db.rawQuery(query, [rawMaterialId]);
    return List.generate(maps.length, (i) {
      return Goods.fromMap(maps[i]);
    });
  }

  Future close() async {
    final db = await _database; // Use the static field directly
    if (db != null && db.isOpen) {
      await db.close();
      _database = null; // Important to nullify for re-initialization if needed
    }
  }
}